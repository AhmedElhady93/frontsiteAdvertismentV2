/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.5.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AdvertisementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applyForAdvertisement(body: ApplyForAdvertisementCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/apply-for-advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyForAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyForAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApplyForAdvertisement(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAdvertisementWithoutSpace(body: CreateAdvertisementWithoutSPaceCommand | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/add-advertisement-without-space";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdvertisementWithoutSpace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdvertisementWithoutSpace(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdvertisementWithoutSpace(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReservationByClient(body: CreateReservationByClientCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/create-reservation-by-client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReservationByClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReservationByClient(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReservationByClient(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stopAd(body: StopAdvertisementCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/stop-ad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopAd(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processStopAd(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCommercialRecord(body: AddCommercialRecordCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/add-commercial-record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCommercialRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCommercialRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddCommercialRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPaidService(body: AddPaidServicesCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/add-paid-service";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPaidService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPaidService(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddPaidService(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editAdvertisement(body: EditAdvertisementCommand | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/edit-Advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processEditAdvertisement(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAdvertisement(body: CreateAdvertisementCommand | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/add-advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdvertisement(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param enable (optional) 
     * @param body (optional) 
     * @return Success
     */
    disableAdvertisement(enable: boolean | undefined, body: string | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/disable-Advertisement?";
        if (enable === null)
            throw new Error("The parameter 'enable' cannot be null.");
        else if (enable !== undefined)
            url_ += "enable=" + encodeURIComponent("" + enable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processDisableAdvertisement(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllAdvertisement(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<AdvertisementDtoPageList> {
        let url_ = this.baseUrl + "/api/Advertisement/get-all-advertisement?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAdvertisement(response: HttpResponseBase): Observable<AdvertisementDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchAdvertisement(body: SearchAdvertisementCommand | undefined): Observable<AdvertisementDtoPageList> {
        let url_ = this.baseUrl + "/api/Advertisement/Search-Advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processSearchAdvertisement(response: HttpResponseBase): Observable<AdvertisementDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDtoPageList>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAdvertisementDetail(id: string | undefined): Observable<SpaceInfoDto> {
        let url_ = this.baseUrl + "/api/Advertisement/get-advertisement-detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertisementDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertisementDetail(<any>response_);
                } catch (e) {
                    return <Observable<SpaceInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpaceInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvertisementDetail(response: HttpResponseBase): Observable<SpaceInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpaceInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpaceInfoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAdvertisementById(id: string | undefined): Observable<AdsDto> {
        let url_ = this.baseUrl + "/api/Advertisement/get-advertisement-ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertisementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertisementById(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvertisementById(response: HttpResponseBase): Observable<AdsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto>(<any>null);
    }

    /**
     * @param lat (optional) 
     * @param lng (optional) 
     * @return Success
     */
    getTopAds(lat: number | undefined, lng: number | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-top-ads?";
        if (lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&"; 
        if (lng === null)
            throw new Error("The parameter 'lng' cannot be null.");
        else if (lng !== undefined)
            url_ += "Lng=" + encodeURIComponent("" + lng) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopAds(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopAds(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyAds(body: GetMyAds | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-ads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyAds(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyAds(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMySpaces(body: GetMySpaces | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-Spaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMySpaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMySpaces(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMySpaces(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgetPassword(body: ForgetPasswordCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyCode(body: VerifyCodeCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/verify-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyCode(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyCode(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientRegister(body: ClientRegisterCommand | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/Auth/client-register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientRegister(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processClientRegister(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serviceProviderRegister(body: ServiceProviderRegisterCommand | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/Auth/service-provider-register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceProviderRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceProviderRegister(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processServiceProviderRegister(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserById(body: GetUserByIdCommand | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/Auth/Get-User-By-Id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }
}

@Injectable()
export class RegionManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    cities(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<CityDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCities(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processCities(response: HttpResponseBase): Observable<CityDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageList>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    countries(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }
}

@Injectable()
export class CitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param countryId (optional) 
     * @return Success
     */
    getCitiesByCountryId(countryId: string | undefined): Observable<CityDto[]> {
        let url_ = this.baseUrl + "/api/region-management/cities/Get-cities-by-country-id?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCitiesByCountryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitiesByCountryId(<any>response_);
                } catch (e) {
                    return <Observable<CityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitiesByCountryId(response: HttpResponseBase): Observable<CityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCity(body: AddCityCommand | undefined): Observable<CityDtoPageListPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities/add-city";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCity(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageListPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageListPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddCity(response: HttpResponseBase): Observable<CityDtoPageListPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageListPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageListPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editCity(id: string, body: EditCityCommand | undefined): Observable<CityDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities/edit-city/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCity(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditCity(response: HttpResponseBase): Observable<CityDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCity(id: string): Observable<CityDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities/delete-city/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCity(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCity(response: HttpResponseBase): Observable<CityDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageList>(<any>null);
    }
}

@Injectable()
export class CountriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    getDdl(query: GetAllCountriesCommand | undefined): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/region-management/Countries/get-ddl?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDdl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDdl(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDdl(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCountry(body: CreateCountryCommand | undefined): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries/add-Country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddCountry(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editCountry(id: string, body: EditCountryCommand | undefined): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries/edit-Country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditCountry(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCountry(id: string): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries/delete-country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCountry(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param serviceTypeId (optional) 
     * @return Success
     */
    getServicesListByTypeId(serviceTypeId: string | undefined): Observable<ServiceDto[]> {
        let url_ = this.baseUrl + "/get-services-List-by-type-id?";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServicesListByTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServicesListByTypeId(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetServicesListByTypeId(response: HttpResponseBase): Observable<ServiceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDto[]>(<any>null);
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    getServiceTypesList(query: GetServiceTypeListCommand | undefined): Observable<ServiceTypeDto[]> {
        let url_ = this.baseUrl + "/get-service-types-List?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceTypesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceTypesList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceTypesList(response: HttpResponseBase): Observable<ServiceTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDto[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getService(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<ServiceTypeDtoPageList> {
        let url_ = this.baseUrl + "/get-service?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetService(response: HttpResponseBase): Observable<ServiceTypeDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDtoPageList>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    services(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<ServiceTypeDtoPageList> {
        let url_ = this.baseUrl + "/Services?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServices(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processServices(response: HttpResponseBase): Observable<ServiceTypeDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDtoPageList>(<any>null);
    }
}

@Injectable()
export class ServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addService(body: CreateServiceCommand | undefined): Observable<ServiceDtoPageList> {
        let url_ = this.baseUrl + "/Services/add-Service";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddService(response: HttpResponseBase): Observable<ServiceDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editService(id: string, body: EditServiceCommand | undefined): Observable<ServiceDtoPageList> {
        let url_ = this.baseUrl + "/Services/edit-Service/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditService(response: HttpResponseBase): Observable<ServiceDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteService(id: string): Observable<ServiceDtoPageList> {
        let url_ = this.baseUrl + "/Services/delete-Service/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteService(response: HttpResponseBase): Observable<ServiceDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDtoPageList>(<any>null);
    }
}

@Injectable()
export class UserManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    roles(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processRoles(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    permissions(): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermissions(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processPermissions(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPermission(body: AddPermissionToRolCommand | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/add-permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPermission(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddPermission(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    users(body: AddUserCommand | undefined): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processUsers(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }
}

@Injectable()
export class RolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRole(body: AddRoleCommand | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles/add-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddRole(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editRole(id: string, body: EditRoleCommand | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles/edit-role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditRole(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRole(id: string): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles/delete-role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }
}

@Injectable()
export class UsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getallusers(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users/getallusers?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallusers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallusers(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetallusers(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editUser(id: string, body: EditUserCommand | undefined): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users/edit-user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditUser(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: string): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users/delete-user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }
}

export class ApplyForAdvertisementCommand {
    adId?: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    servicesIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["servicesIds"])) {
                this.servicesIds = [] as any;
                for (let item of _data["servicesIds"])
                    this.servicesIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplyForAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyForAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        if (Array.isArray(this.servicesIds)) {
            data["servicesIds"] = [];
            for (let item of this.servicesIds)
                data["servicesIds"].push(item);
        }
        return data; 
    }
}

export class CreateAdvertisementWithoutSPaceCommand {
    spaceInfoId?: string | undefined;
    images?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    auctionDays?: number;
    freeServiceIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.spaceInfoId = _data["spaceInfoId"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.auctionDays = _data["auctionDays"];
            if (Array.isArray(_data["freeServiceIds"])) {
                this.freeServiceIds = [] as any;
                for (let item of _data["freeServiceIds"])
                    this.freeServiceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAdvertisementWithoutSPaceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdvertisementWithoutSPaceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["spaceInfoId"] = this.spaceInfoId;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["auctionDays"] = this.auctionDays;
        if (Array.isArray(this.freeServiceIds)) {
            data["freeServiceIds"] = [];
            for (let item of this.freeServiceIds)
                data["freeServiceIds"].push(item);
        }
        return data; 
    }
}

export enum AdType {
    _0 = 0,
    _1 = 1,
}

export enum AuctionStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum AdCategoryEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class AdvertisementDto {
    id?: string | undefined;
    vendorName?: string | undefined;
    image?: string | undefined;
    title?: string | undefined;
    adType?: AdType;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    rejected?: boolean;
    cityId?: string | undefined;
    cityName?: { [key: string]: string; } | undefined;
    clientId?: string | undefined;
    lat?: number;
    lng?: number;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    seriousSubscriptionAmount?: number;
    auctionStatus?: AuctionStatus;
    auctionDays?: number;
    adCategory?: AdCategoryEnum;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorName = _data["vendorName"];
            this.image = _data["image"];
            this.title = _data["title"];
            this.adType = _data["adType"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.rejected = _data["rejected"];
            this.cityId = _data["cityId"];
            if (_data["cityName"]) {
                this.cityName = {} as any;
                for (let key in _data["cityName"]) {
                    if (_data["cityName"].hasOwnProperty(key))
                        this.cityName![key] = _data["cityName"][key];
                }
            }
            this.clientId = _data["clientId"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.seriousSubscriptionAmount = _data["seriousSubscriptionAmount"];
            this.auctionStatus = _data["auctionStatus"];
            this.auctionDays = _data["auctionDays"];
            this.adCategory = _data["adCategory"];
        }
    }

    static fromJS(data: any): AdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        data["image"] = this.image;
        data["title"] = this.title;
        data["adType"] = this.adType;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["rejected"] = this.rejected;
        data["cityId"] = this.cityId;
        if (this.cityName) {
            data["cityName"] = {};
            for (let key in this.cityName) {
                if (this.cityName.hasOwnProperty(key))
                    data["cityName"][key] = this.cityName[key];
            }
        }
        data["clientId"] = this.clientId;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["seriousSubscriptionAmount"] = this.seriousSubscriptionAmount;
        data["auctionStatus"] = this.auctionStatus;
        data["auctionDays"] = this.auctionDays;
        data["adCategory"] = this.adCategory;
        return data; 
    }
}

export class CreateReservationByClientCommand {
    adId?: string | undefined;
    duration?: number;
    services?: string[] | undefined;
    amount?: number;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(item);
            }
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): CreateReservationByClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReservationByClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["duration"] = this.duration;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item);
        }
        data["amount"] = this.amount;
        return data; 
    }
}

export class StopAdvertisementCommand {
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StopAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StopAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export class AddCommercialRecordCommand {
    images?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
        }
    }

    static fromJS(data: any): AddCommercialRecordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddCommercialRecordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        return data; 
    }
}

export class PaidServicesDto {
    serviceTypeId?: string | undefined;
    price?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.serviceTypeId = _data["serviceTypeId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PaidServicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaidServicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceTypeId"] = this.serviceTypeId;
        data["price"] = this.price;
        return data; 
    }
}

export class AddPaidServicesCommand {
    paidServices?: PaidServicesDto[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paidServices"])) {
                this.paidServices = [] as any;
                for (let item of _data["paidServices"])
                    this.paidServices!.push(PaidServicesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddPaidServicesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPaidServicesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paidServices)) {
            data["paidServices"] = [];
            for (let item of this.paidServices)
                data["paidServices"].push(item.toJSON());
        }
        return data; 
    }
}

export class EditAdvertisementCommand {
    id?: string | undefined;
    images?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    cityId?: string | undefined;
    lat?: number;
    lng?: number;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    auctionDays?: number;
    adCategory?: AdCategoryEnum;
    freeServiceIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.cityId = _data["cityId"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.auctionDays = _data["auctionDays"];
            this.adCategory = _data["adCategory"];
            if (Array.isArray(_data["freeServiceIds"])) {
                this.freeServiceIds = [] as any;
                for (let item of _data["freeServiceIds"])
                    this.freeServiceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): EditAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["cityId"] = this.cityId;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["auctionDays"] = this.auctionDays;
        data["adCategory"] = this.adCategory;
        if (Array.isArray(this.freeServiceIds)) {
            data["freeServiceIds"] = [];
            for (let item of this.freeServiceIds)
                data["freeServiceIds"].push(item);
        }
        return data; 
    }
}

export class CreateAdvertisementCommand {
    images?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: AdType;
    adCategory?: AdCategoryEnum;
    cityId?: string | undefined;
    lat?: number;
    lng?: number;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    auctionDays?: number;
    freeServiceIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.adCategory = _data["adCategory"];
            this.cityId = _data["cityId"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.auctionDays = _data["auctionDays"];
            if (Array.isArray(_data["freeServiceIds"])) {
                this.freeServiceIds = [] as any;
                for (let item of _data["freeServiceIds"])
                    this.freeServiceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["adCategory"] = this.adCategory;
        data["cityId"] = this.cityId;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["auctionDays"] = this.auctionDays;
        if (Array.isArray(this.freeServiceIds)) {
            data["freeServiceIds"] = [];
            for (let item of this.freeServiceIds)
                data["freeServiceIds"].push(item);
        }
        return data; 
    }
}

export class PagedListMetaData {
    readonly pageCount?: number;
    readonly totalItemCount?: number;
    readonly pageNumber?: number;
    readonly pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    readonly isFirstPage?: boolean;
    readonly isLastPage?: boolean;
    readonly firstItemOnPage?: number;
    readonly lastItemOnPage?: number;

    init(_data?: any) {
        if (_data) {
            (<any>this).pageCount = _data["pageCount"];
            (<any>this).totalItemCount = _data["totalItemCount"];
            (<any>this).pageNumber = _data["pageNumber"];
            (<any>this).pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).isFirstPage = _data["isFirstPage"];
            (<any>this).isLastPage = _data["isLastPage"];
            (<any>this).firstItemOnPage = _data["firstItemOnPage"];
            (<any>this).lastItemOnPage = _data["lastItemOnPage"];
        }
    }

    static fromJS(data: any): PagedListMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        data["totalItemCount"] = this.totalItemCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["isFirstPage"] = this.isFirstPage;
        data["isLastPage"] = this.isLastPage;
        data["firstItemOnPage"] = this.firstItemOnPage;
        data["lastItemOnPage"] = this.lastItemOnPage;
        return data; 
    }
}

export class AdvertisementDtoPageList {
    items?: AdvertisementDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdvertisementDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class SearchAdvertisementCommand {
    countryId?: string[] | undefined;
    cityId?: string[] | undefined;
    title?: string | undefined;
    maxPrice?: number;
    minPrice?: number;
    adCategoryies?: AdCategoryEnum[] | undefined;
    page?: number;
    pageSize?: number;
    sortBy?: string | undefined;
    sortOrder?: string | undefined;
    filter?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countryId"])) {
                this.countryId = [] as any;
                for (let item of _data["countryId"])
                    this.countryId!.push(item);
            }
            if (Array.isArray(_data["cityId"])) {
                this.cityId = [] as any;
                for (let item of _data["cityId"])
                    this.cityId!.push(item);
            }
            this.title = _data["title"];
            this.maxPrice = _data["maxPrice"];
            this.minPrice = _data["minPrice"];
            if (Array.isArray(_data["adCategoryies"])) {
                this.adCategoryies = [] as any;
                for (let item of _data["adCategoryies"])
                    this.adCategoryies!.push(item);
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.sortBy = _data["sortBy"];
            this.sortOrder = _data["sortOrder"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): SearchAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countryId)) {
            data["countryId"] = [];
            for (let item of this.countryId)
                data["countryId"].push(item);
        }
        if (Array.isArray(this.cityId)) {
            data["cityId"] = [];
            for (let item of this.cityId)
                data["cityId"].push(item);
        }
        data["title"] = this.title;
        data["maxPrice"] = this.maxPrice;
        data["minPrice"] = this.minPrice;
        if (Array.isArray(this.adCategoryies)) {
            data["adCategoryies"] = [];
            for (let item of this.adCategoryies)
                data["adCategoryies"].push(item);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["sortBy"] = this.sortBy;
        data["sortOrder"] = this.sortOrder;
        data["filter"] = this.filter;
        return data; 
    }
}

export class SpaceInfoDto {
    id?: string | undefined;
    vendorName?: string | undefined;
    vendorEmail?: string | undefined;
    vendorPhone?: string | undefined;
    images?: string[] | undefined;
    title?: string | undefined;
    adType?: AdType;
    adCategory?: AdCategoryEnum;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    rejected?: boolean;
    cityId?: string | undefined;
    price?: number;
    cityName?: { [key: string]: string; } | undefined;
    lat?: number;
    lng?: number;
    adId?: string | undefined;
    adIntervalFromDate?: Date;
    adIntervalToDate?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorName = _data["vendorName"];
            this.vendorEmail = _data["vendorEmail"];
            this.vendorPhone = _data["vendorPhone"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.adType = _data["adType"];
            this.adCategory = _data["adCategory"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.rejected = _data["rejected"];
            this.cityId = _data["cityId"];
            this.price = _data["price"];
            if (_data["cityName"]) {
                this.cityName = {} as any;
                for (let key in _data["cityName"]) {
                    if (_data["cityName"].hasOwnProperty(key))
                        this.cityName![key] = _data["cityName"][key];
                }
            }
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.adId = _data["adId"];
            this.adIntervalFromDate = _data["adIntervalFromDate"] ? new Date(_data["adIntervalFromDate"].toString()) : <any>undefined;
            this.adIntervalToDate = _data["adIntervalToDate"] ? new Date(_data["adIntervalToDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SpaceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpaceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        data["vendorEmail"] = this.vendorEmail;
        data["vendorPhone"] = this.vendorPhone;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["adType"] = this.adType;
        data["adCategory"] = this.adCategory;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["rejected"] = this.rejected;
        data["cityId"] = this.cityId;
        data["price"] = this.price;
        if (this.cityName) {
            data["cityName"] = {};
            for (let key in this.cityName) {
                if (this.cityName.hasOwnProperty(key))
                    data["cityName"][key] = this.cityName[key];
            }
        }
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["adId"] = this.adId;
        data["adIntervalFromDate"] = this.adIntervalFromDate ? this.adIntervalFromDate.toISOString() : <any>undefined;
        data["adIntervalToDate"] = this.adIntervalToDate ? this.adIntervalToDate.toISOString() : <any>undefined;
        return data; 
    }
}

export class FreeServiceDto {
    adId?: string | undefined;
    serviceTypeId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.serviceTypeId = _data["serviceTypeId"];
        }
    }

    static fromJS(data: any): FreeServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FreeServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["serviceTypeId"] = this.serviceTypeId;
        return data; 
    }
}

export class AdsDto {
    id?: string | undefined;
    adType?: AdType;
    description?: string | undefined;
    address?: string | undefined;
    lng?: string | undefined;
    lat?: string | undefined;
    title?: string | undefined;
    cityId?: string | undefined;
    countryId?: string | undefined;
    vendorName?: string | undefined;
    price?: number;
    fromDate?: Date;
    toDate?: Date;
    images?: string[] | undefined;
    rejected?: boolean;
    adCategory?: AdCategoryEnum;
    freeServices?: FreeServiceDto[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adType = _data["adType"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.lng = _data["lng"];
            this.lat = _data["lat"];
            this.title = _data["title"];
            this.cityId = _data["cityId"];
            this.countryId = _data["countryId"];
            this.vendorName = _data["vendorName"];
            this.price = _data["price"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.rejected = _data["rejected"];
            this.adCategory = _data["adCategory"];
            if (Array.isArray(_data["freeServices"])) {
                this.freeServices = [] as any;
                for (let item of _data["freeServices"])
                    this.freeServices!.push(FreeServiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adType"] = this.adType;
        data["description"] = this.description;
        data["address"] = this.address;
        data["lng"] = this.lng;
        data["lat"] = this.lat;
        data["title"] = this.title;
        data["cityId"] = this.cityId;
        data["countryId"] = this.countryId;
        data["vendorName"] = this.vendorName;
        data["price"] = this.price;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["rejected"] = this.rejected;
        data["adCategory"] = this.adCategory;
        if (Array.isArray(this.freeServices)) {
            data["freeServices"] = [];
            for (let item of this.freeServices)
                data["freeServices"].push(item.toJSON());
        }
        return data; 
    }
}

export class GetMyAds {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMyAds {
        data = typeof data === 'object' ? data : {};
        let result = new GetMyAds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class GetMySpaces {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMySpaces {
        data = typeof data === 'object' ? data : {};
        let result = new GetMySpaces();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class LoginCommand {
    username?: string | undefined;
    password?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export class Result {
    success?: boolean;
    errors?: string[] | undefined;
    data?: any | undefined;
    message?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.data = _data["data"];
            if (_data["message"]) {
                this.message = {} as any;
                for (let key in _data["message"]) {
                    if (_data["message"].hasOwnProperty(key))
                        this.message![key] = _data["message"][key];
                }
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["data"] = this.data;
        if (this.message) {
            data["message"] = {};
            for (let key in this.message) {
                if (this.message.hasOwnProperty(key))
                    data["message"][key] = this.message[key];
            }
        }
        return data; 
    }
}

export class ChangePasswordCommand {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmNewPassword?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmNewPassword = _data["confirmNewPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmNewPassword"] = this.confirmNewPassword;
        return data; 
    }
}

export class ForgetPasswordCommand {
    username?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): ForgetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        return data; 
    }
}

export class VerifyCodeCommand {
    code?: number;
    username?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): VerifyCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        return data; 
    }
}

export class ResetPasswordCommand {
    password?: string | undefined;
    confirmPassword?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["email"] = this.email;
        data["token"] = this.token;
        return data; 
    }
}

export class ClientRegisterCommand {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    fullName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ClientRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export class ClientDto {
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export class ServiceProviderRegisterCommand {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    fullName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ServiceProviderRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export class GetUserByIdCommand {
    userId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): GetUserByIdCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data; 
    }
}

export class CityDto {
    name?: { [key: string]: string; } | undefined;
    countryName?: { [key: string]: string; } | undefined;
    id?: string | undefined;
    countryId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            if (_data["countryName"]) {
                this.countryName = {} as any;
                for (let key in _data["countryName"]) {
                    if (_data["countryName"].hasOwnProperty(key))
                        this.countryName![key] = _data["countryName"][key];
                }
            }
            this.id = _data["id"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        if (this.countryName) {
            data["countryName"] = {};
            for (let key in this.countryName) {
                if (this.countryName.hasOwnProperty(key))
                    data["countryName"][key] = this.countryName[key];
            }
        }
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export class CityDtoPageList {
    items?: CityDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CityDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CityDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddCityCommand {
    countryId?: string | undefined;
    name?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
        }
    }

    static fromJS(data: any): AddCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        return data; 
    }
}

export class CityDtoPageListPageList {
    items?: CityDtoPageList[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CityDtoPageList.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CityDtoPageListPageList {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoPageListPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class EditCityCommand {
    countryId?: string | undefined;
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class GetAllCountriesCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetAllCountriesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCountriesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class CountryDto {
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class CountryDtoPageList {
    items?: CountryDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CountryDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class CreateCountryCommand {
    name?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        return data; 
    }
}

export class EditCountryCommand {
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class ServiceDto {
    userName?: string | undefined;
    price?: number;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.price = _data["price"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["price"] = this.price;
        data["id"] = this.id;
        return data; 
    }
}

export class GetServiceTypeListCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetServiceTypeListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetServiceTypeListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class ServiceTypeDto {
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ServiceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class ServiceTypeDtoPageList {
    items?: ServiceTypeDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ServiceTypeDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceTypeDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTypeDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class CreateServiceCommand {
    name?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        return data; 
    }
}

export class ServiceDtoPageList {
    items?: ServiceDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ServiceDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class EditServiceCommand {
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class RoleDto {
    name?: string | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export class RoleDtoPageList {
    items?: RoleDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddRoleCommand {
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export class EditRoleCommand {
    name?: string | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export class AddPermissionToRolCommand {
    permission?: string | undefined;
    roleId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.permission = _data["permission"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): AddPermissionToRolCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPermissionToRolCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["roleId"] = this.roleId;
        return data; 
    }
}

export class UserDto {
    id?: string | undefined;
    fullName?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    roles?: string[] | undefined;
    phoneNumber?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.avatar = _data["avatar"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["avatar"] = this.avatar;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export class UserDtoPageList {
    items?: UserDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddUserCommand {
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    avatar?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): AddUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["avatar"] = this.avatar;
        return data; 
    }
}

export class EditUserCommand {
    id?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    avatar?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): EditUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["avatar"] = this.avatar;
        return data; 
    }
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}